
\section{Some Building Blocks for LUT-based Evaluation}
\label{sec:previous-blocks}

\TODO{Réécrire pour éviter le plagiat}

In this section, we present the approach from \cite{DBLP:conf/wahc/TramaCBS23}, some components of which we use for our own work. We formally present some advanced homomorphic primitives used in this work that we reuse as well.


\cite{DBLP:conf/wahc/TramaCBS23} is a ``Full-LUT'' approach, that is to say AES is evaluated entirely with TFHE's programmable bootstrapping, encoding exclusively all operations within LUTs. To meet the performance constraints of the bootstrapping algorithm, this method operates on elements in $\Z_{16}$, ensuring efficient computation.

\subsection{AES Subroutines as LUTs}

The \SubBytes step, which involves the evaluation of an Sbox, is inherently a LUT operation and is therefore naturally implemented in FHE using a PBS. However, it must be evaluated over $\Z_{16}$ rather than $GF(256)$ for efficiency reasons. Converting the other AES steps into LUT evaluations also requires additional effort.

In particular, in the original AES design \cite{aes-original}, the \MixColumns step is computed using a series of XOR operations and multiplications in $GF(256)$. Unfortunately, TFHE’s native cleartext-ciphertext multiplication cannot directly handle these $GF(256)$ multiplications because of the polynomial nature of the elements of this field. As a result, \MixColumns must be reformulated as a LUT evaluation.

Additionally, the \AddRoundKey step, which uses XOR as its key operation, presents its own challenges because XOR is a bivariate operation that requires two inputs. Classical bootstrapping, which operates on single inputs, is insufficient for this purpose. To address this, the authors utilize a specialized bootstrapping method that supports operations on multiple encrypted inputs.

\subsection{LUTs Evaluation} 
Since the AES evaluation involves computing an 8-bit Sbox, a straightforward solution would be to work with 8-bit messages. With such messages, the homomorphic Sbox evaluation would require only one bootstrapping per byte. However, processing messages with more bits significantly slow down the bootstrapping process. For example, with 8-bit inputs, TFHE parameters result in bootstrapping times of approximately 1.5 seconds per byte on a standard laptop, making direct evaluation of the 8-bit Sbox (and other LUTs) infeasible.

To address this issue, \cite{DBLP:conf/wahc/TramaCBS23} proposes a decomposition approach and demonstrates that the optimal representation of 8-bit inputs for their purpose is in $\Z_{16}$. Specifically, a message $m \in \{0, \cdots, 255\}$ is split into two 4-bit chunks (or \emph{nibbles}) $h$ and $l$ such that $m = 16h+l$. The encryption of $m$ is then represented as two ciphertexts encrypting $h$ and $l$ with the same key $\lweSecretKey$.

However, bootstrapping these decomposed inputs requires a method capable of handling multiple encrypted inputs. The authors explore several approaches for this, namely the chain-based method and the tree-based method \cite{TCHES:GuiBorAra21}. Their analysis concludes that the Tree-Based Method (TBM) is the most suitable for their needs. They also relies on the Multi-Value Bootstrapping (MVB) to produce several outputs for the cost of one PBS. We provide details about TBM and MVB in the following:

\paragraph{Multi-Value Bootstrapping from \cite{RSA:CarIzaMol19}.}
\label{primitive:mvb}
%
Multi-Value Bootstrapping (MVB) is a technique that enables the evaluation of $k$ distinct Look-Up Tables $(f_i)_{1 \le i \le k}$ on a single encrypted input, using only one $\BlindRotate$. This method is based on the factorization of the accumulator polynomials $\textsf{acc}_i(X)$ associated with each function $f_i$. Specifically, each accumulator polynomial is expressed as: 
$$
    \textsf{acc}_i(X) = \sum_{j=0}^{N-1} \alpha_{i,j} X^j, \quad \alpha_{i,j} \in \mathbb{Z}_q.
$$
The factorization then splits it into two parts: 
$$
    acc_i(X) = v_0(X) \cdot v_i(X) \mod (X^N + 1),
$$
where $v_0(X)$ is a common factor shared across all accumulators set as:
$$
    v_0(X) = \frac{1}{2} \cdot (1 + X + \dots + X^{N-1}),
$$
and $v_i(X)$ is a distinct factor specific to each function $f_i$:
$$
    v_i(X) = \alpha_{i, 0} + \alpha_{i, N-1} + (\alpha_{i, 1} - \alpha_{i, 0}) \cdot X + \dots + (\alpha_{i, N-1} - \alpha_{i, N-2}) \cdot X^{N-1}.
$$
This factorization is made possible thanks to the identity:
$$
(1 + X + \dots + X^{N-1}) \cdot (1-X) \equiv 2 \mod (X^N + 1).
$$
By leveraging this factorization and as illustrated on Figure~\ref{fig:mvb}, multiple LUTs can be evaluated on a single encrypted input by performing the following steps:
\begin{enumerate}
\item Computing a $\BlindRotate$ operation on an accumulator polynomial initialized with the value of $v_0$.
\item Then multiplying with \texttt{ClearMultTFHE} the obtained rotated polynomial by each $v_i(X)$ corresponding to the LUT of $f_i$ to obtain the respective $\textsf{acc}_i(X)$.
\end{enumerate}
Finally, at the cost of a single $\BlindRotate$ and $k$ cleartext-ciphertext GLWE multiplications, one can obtain the evaluation of $k$ different LUTs on one single encrypted input. Moreover, this specific choice of factorization allows for a very-low norm for the vectors $v_i$'s (which in practice are very sparse), and so a very-low noise expansion.

\TODO{Refaire ma propre figure}
\begin{figure}
    \centering
%    \includegraphics[width=0.8\textwidth]{figures/mvb.pdf}
    \caption{Difference between classic bootstrapping of several LUTs on a single input (a) and the use of MVB (b). Pink arrows represent cleartext-ciphertext RLWE multiplications. Figure extracted from \cite{DBLP:conf/wahc/TramaCBS23}.)}
    \label{fig:mvb}
\end{figure}

This MVB primitive thus allows significant speed-ups in the implementation of \cite{DBLP:conf/wahc/TramaCBS23}, in particular in the evaluation of the Sbox or in the multiplications in $GF(256)$ that occur during the \MixColumns step. Indeed, since each byte is decomposed into two nibbles $h$ and $l$, the LUT corresponding, for instance, to the Sbox must also be decomposed into two tables: one providing the most significant nibble and one providing the least significant nibble. That is to say: 
$$
\texttt{tab}_{\textsc{msn}}[i] = \left\lfloor \frac{\texttt{Sbox}[i]}{16} \right\rfloor \quad \text{and} \quad \texttt{tab}_{\textsc{lsn}}[i] = \texttt{Sbox}[i] \mod 16.
$$
Each of these tables must be evaluated on an 8-bit payload ciphertext. 


\paragraph{Tree-Based Method from \cite{DBLP:conf/wahc/TramaCBS23}.}
\label{prim:tbb}

Let $B, B', d \in \mathbb N^*$. The Tree-Based Method (TBM) allows to evaluate a LUT $f: \Z_{B^d} \mapsto \Z_ {B'}$ with a large input size $B^d$, by processing $d$ limbs of data in $\Z_B$. We consider input messages that are written as:
$$
    m = \sum_{i=0}^{d-1} m_i B^i, \quad \text{with } m_i \in \mathbb{Z}_B,
$$
and that are represented by $d$ ciphertexts $(c_0, c_1, \dots, c_{d-1})$ corresponding to the $d$ message components $(m_0, m_1, \dots, m_{d-1})$. 
%
To evaluate $f$, we encode a LUT for $f$ using $B^{d-1}$ accumulators, each represented by a polynomial $\textsf{acc}_i(X)$. These accumulators encode the functions:
%
    \begin{align*}
        f_i: \Z_B &\rightarrow \Z_{B'}\\
             x &\mapsto f(i + x \cdot B^{d-1})
    \end{align*}
%
Next, we apply a $\sf{BlindRotate}$ and a $\sf{SampleExtract}$ to each accumulator $acc_i(X)$, using $c_{d-1}$ as the selector. This operation produces $B^{d-1}$ LWE ciphertexts, each encrypting $f (i + m_{d-1} \cdot B^{d-1})$ for $i \in \Z_{B^{d-1}}$.
%    
Finally, a $\sf{Keyswitch}$ operation from LWE to GLWE aggregates these ciphertexts into $B^{d-2}$ GLWE encryptions, representing the LUT of $h$, defined as:
    \begin{align*}
        h &: (\Z_{B})^{d-1} \mapsto \Z_B' \\
          & (a_0, \dots, a_{d-1}) \mapsto f \circ g(a_0, \dots, a_{d-2}, m_{d-1})
    \end{align*}
using the bijection $g$, which reverses the decomposition:
    \begin{align*}
        g: (\Z_B)^d &\rightarrow \Z_{B^d} \\
           (a_0, \dots, a_{d-1}) &\mapsto \sum_{i=0}^{d-1} a_i \cdot B^i
    \end{align*} 

This process is repeated iteratively, using the next ciphertext at each step, until a single LWE ciphertext encrypting $f(m_0, \dots, m_{d-1})$ is obtained.  

\TODO{Refaire ma propre figure}
\begin{figure}
    \centering
%    \includegraphics[width=0.8\textwidth]{figures/tree_method.pdf}
    \caption{Illustration of the tree-based method on messages  $m_1 = 1, m_2=2$ in the space  $\mathbb{Z}_4$. The corresponding ciphertexts are $c_1 \in \mathrm{}(m_1)$ and $c_2 \in \mathrm{LWE}(m_2)$. We apply the addition in $\mathbb{Z}_4$ via programmable bootstrapping. Red arrows indicate bootstrappings. (Figure inspired by \cite{DBLP:conf/wahc/TramaCBS23}.)}
    \label{fig:my_label}
\end{figure}

In the implementation described in \cite{DBLP:conf/wahc/TramaCBS23}, this primitive is employed to evaluate an 8-bit LUT by dividing it into two limbs of 4 bits each, which they determined to be optimal for their specific setting. 
%
To further enhance the performance of the TBM, the blind rotations for the accumulators $acc_i(X)$ of \emph{the first layer of the tree} can be performed simultaneously using the MVB technique (as discussed in~\cite{TCHES:GuiBorAra21}). 

Finally, the ``full-LUT'' approach facilitates efficient computation of the Sbox through the Tree-Based Method, as opposed to directly evaluating the corresponding Boolean circuit. However, this approach also requires LUT-based computation of XOR operations and other intermediary steps, which is notably slower when operating in $\Z_{16}$ compared to binary messages. Consequently, our new method \hippo{} proposed in this chapter strategically applies LUT evaluation exclusively where it is most effective and yields the best performance, namely for the evaluation of the Sbox.




\section{Generalization of $p$-encodings to Arithmetic Case}
\label{sec:generalization_p_encodings}

\TODO{Repasser sur cette sections}

In Chapter \ref{chap:p_encodings} of this thesis, we presented the a construction that we called $p$-encodings and used it in Section \ref{sec:p_encodings_aes} to evaluate AES homomorphically. 

In this method, data is encrypted bit per bit and only Boolean operations are performed. It leverages the fact that, in the plaintext space $\Z_2$, the \texttt{SumTFHE} operation actually performs a XOR. Thus, the linear operations \MixColumns and \AddRoundKey can be efficiently performed with minimal cost, using only the homomorphic sum of TFHE.
%
Furthermore, because operations are performed on individual bits, the \ShiftRows transformation can be evaluated for free, as it merely involves rearranging the ciphertexts.

Evaluating \SubBytes is trickier. Using $p=2$, it is impossible to perform a bivariate Boolean gate other than XOR. Thus, evaluating the Boolean circuit of the Sbox cannot be done. Thanks to the notion of $p$-encoding, we embedded the bits into a larger space $\Z_p$ with $p > 2$ to construct other Boolean gates.  

In this chapter, we now generalize this notion beyond the Boolean case by defining the $(o, p)$- encoding construction. Informally, instead of embedding the Boolean space in $\Z_p$, we embed any space $\Z_o$ in $\Z_p$ (with $o < p$). So, what was called $p$-encoding in Chapter \ref{chap:hyppogriph} corresponds to a $(2, p)$-encoding in this one.
%
Definition \ref{def:encoding} formalizes this generalization.

\begin{definition}[$(o, p)$-encoding]
	Let $\Z_o$ be the message space. A \emph{$(o, p)$-encoding} is a function $\Encoding: \Z_o \mapsto 2^{\Z_p}$ that maps each element of $\Z_o$ to a subset of the discretized torus $\Z_p$. A $(o, p)$-encoding is \emph{valid} if and only if:
	\begin{equation}
		\begin{cases}
			\forall (i, j) \in \Z_o^2, i \ne j, \Encoding(i) \cap \Encoding(j) = \emptyset~\text{ and}\\
			\text{if $p$ is even:} ~\forall \:x \in \mathbb Z_p, \forall i \in \Z_o: x \in \Encoding(i) \iff \left [ x + \frac p 2 \right ]_p \in \Encoding([-i]_o)
		\end{cases}
		\label{def:validity}
	\end{equation}
	The latter property is a direct consequence of the negacyclicity problem, which we discussed extensively in Chapter \ref{chap:negacyclicity}.
	\label{def:encoding}
\end{definition}

In this work, we focus exclusively on cases where $p=2$ or $p$ is an odd prime. As a result, a lot of the subleties of negacyclicity can be overlooked. Furthermore, among the various types of $(o, p)$-encodings, one particular class proves especially useful for our purposes: the \textit{canonical} $(o, p)$-encoding.

\begin{definition}[canonical $(o, p)$-encoding]
	\label{def:canonical-encoding}
	A $(o, p)$-encoding $\Encoding$ is said \textit{canonical} if and only if it verifies: 
	\begin{align*}
		\Encoding: \Z_o &\rightarrow \Z_p\\
		x &\mapsto x
	\end{align*}
	(with $o < p$). Informally, we simply embed a smaller space into a larger one, without altering the order of the elements.
\end{definition}


In Chapter \ref{chap:p_encodings} the Boolean space is used (so $o=2$). The \SubBytes circuit is evaluated using $(2,11)$-encoding, while the rest is evaluated with a $(2, 2)$-encoding (\ie~the trivial encoding of TFHE). Consequently, an \textit{Encoding Switching} operation is required. This operation can be straightforwardly performed using a PBS.

\begin{definition}[Encoding Switching]
	\label{def:encoding-switching}
	Let $c$ be a ciphertext encrypting a message $m \in \Z_o$ under the $(o, p)$-encoding $\Encoding$. Its encoding can be switched to the $(o, p')$-encoding $\Encoding'$ by applying a PBS on $c$ evaluating the function:
	
	\begin{align*}
		\texttt{Cast}_{\Encoding \mapsto \Encoding'}: \Z_p &\rightarrow \Z_{p'}\\
		x &\mapsto x'
	\end{align*}
	where $x'$ is defined as $\forall i \in \Z_o, x \in \Encoding(i) \implies x' \in \Encoding'(i)$.
\end{definition}


