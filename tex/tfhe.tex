% !TeX_ROOT=../thesis.tex

\chapter{TFHE}



\section{Basics on $\LWE$ and $\GLWE$ Encryption}


\subsection{Hardness assumptions}


\paragraph{Original $\LWE$ problem}

In 2005, Regev defined the Learning With Errors ($\LWE$) problem in \cite{regev_lwe}. With this work, he laid the foundations for an important part of modern lattice-based cryptography. The version usually used in FHE literature is presented in Definition \ref{def:LWE}:


\begin{definition}
	(Learning with Errors). Let $q$ and $n$ two integers, respectively called \textit{modulus} and \textit{dimension}.  and let $\chi_s$ and $\chi_e$ be distributions over small values of $\lweRing$. We sample a vector $\lweSecretKey = (s_0, \dots, s_{n-1}) \drawfrom \chi_s^n$. 
	
	We define the $\LWE$ distribution $\mathcal{D}_{q, n, \chi_s, \chi_e}^{\LWE}$ as:
	
	 \[
	 \mathcal{D}_{q, n, \chi_s, \chi_e}^{\LWE} = \left \{(\vec a, b) \;\middle|\; \vec a = (a_0, \dots, a_{n-1}) \drawfrom \unif{\lweRing}^n, e \drawfrom \chi_e, b = \sum_{j=0}^{n-1} a_j \cdot s_j + e \right \}
	  \]
	 
	 The \textit{decisional} version of the problem is to distinguish this distribution from a uniformely random one, namely:
	
	\[
	\mathcal{D}^{(\textsf{random})} = \left \{(\vec a, r) \;\middle|\; \vec a \drawfrom \unif{\lweRing}^n, r \drawfrom \unif{\lweRing} \right\}
	\]

	The \emph{search} version of the problem is to recover $\lweSecretKey$ from samples of $\mathcal{D}_{q, n, \chi_s, \chi_e}^{\LWE}$. 
	\label{def:LWE}
\end{definition}


Regev showed that the search and decisional problems are reducible to each other and their average case is as hard as worst-case lattice problems.

The hardness of this problem depends on the parameters $q$, $n$, $\chi_s$ and $\chi_e$, and so does the security of the schemes built upon it. To derive a concrete security level $\lambda$ from a parameter set, the state of the art is a tool named \texttt{lattice-estimator} \cite{lattice-estimator}. Users can input concrete values and distributions for the parameters, and the tool evaluates the security of the underlying $\LWE$ instance by running simulations of attacks of the literature.

In Definition \ref{def:LWE}, we did not precise the shapes of the distributions $\chi_s$ and $\chi_e$ (beyond the fact they yields small values). Several distributions are possible: a discrete Gaussian with a small variance, a uniform distribution restricted on a small interval, or a binomial. 

Most implementations of TFHE select a uniform distribution on $\{0, 1\}$ for the secret, and a Gaussian with a small variance $\lweSigma$ for the noise. Thus, we will use these one in this thesis. We will use the notation $\LWE_{(q, n, \sigma)}$ for these instances.



\paragraph{Extension to the Polynomials: $\GLWE$}


Looking for more efficient solutions, $\LWE$ problem has been declined in a \textit{ring variant} in \cite{rlwe}, and further expanded in a multitude of variants since them. A generalized version over rings, named $\GLWE$ and used by TFHE, is presented below. It is very similar to the $\LWE$ one, but deals with polynomial values instead of integers:

\begin{definition}
	(Generalized Learning with Errors) Let $q$, $k$ and $N$ three integers, respectively called \textit{modulus}, \textit{dimension} and \textit{degree}. Let $\chi_S$ and $\chi_E$ be distributions over the small values of $\glweRing$. We sample a vector $\lweSecretKey = (S_0, \dots, S_{k-1}) \drawfrom \chi_S^k$. 
	
	We define the $\GLWE$ distribution $\mathcal{D}_{q, k, N, \chi_S, \chi_E}^{\GLWE}$ as:
	
	\[
	\mathcal{D}_{q, k, N, \chi_S, \chi_E}^{\GLWE} = \left \{ (\vec A, B) \;\middle|\; \vec A = (A_0, \dots, A_{k-1}) \drawfrom \unif{\glweRing}^k, E \drawfrom \chi_E, B = \sum_{j=0}^{k-1} A_j \cdot S_j + E \right \}
	\]
	
	The \textit{decisional} version of the problem is to distinguish this distribution from a uniformely random one, namely:
	
	\[
	\mathcal{D}^{(\textsf{random})} = \left \{(\vec A, R) \;\middle|\; \vec A \drawfrom \unif{\glweRing}^k, R \drawfrom \unif{\glweRing} \right\}
	\]
	
	The \emph{search} version of the problem is to recover $\lweSecretKey$ from samples of $\mathcal{D}_{q, k , N, \chi_S, \chi_E}^{\GLWE}$. 
	\label{def:GLWE}
	
\end{definition}

Note that if we fix $k = 1$, we fall back on the classical $\RLWE$ problem, notably used in BGV \cite{bgv}. Also, taking $N=1$ produces a $\LWE$ instance with $n = k$. 

Concretely, using polynomial rings allows to encode more information in a single sample, yielding more compact ciphertexts and public keys. The schemes can also benefit from high-speed polynomial arithmetic techniques such as FFT. 

General consensus is that hardness of an instance $\GLWE_{(q, k, N, \sigma)}$ is similar to the hardness of $\LWE_{(q, k \cdot N, \sigma)}$, which makes possible to use the \texttt{lattice-estimator} as well.


\TODO{Je ne trouve pas de reference pour ce claim, mais c'est ce que tout le monde fait}






\section{A Word on the Torus equivalence and its discretization}
\label{sec:torus_equivalence}


The T in TFHE stands for \textit{Torus}. This is because in the seminal paper of TFHE \cite{JC:CGGI20}, authors worked with a torus-based version of $\LWE$.


The torus $\T = \R / \Z$ corresponds to the integers modulo 1. It has a $\Z$-module structure, which means that :

\begin{itemize}
	\item The sum of two torus elements is well-defined.
	\item The multiplication between an element of $\T$ and an element of $\Z$ is also well-defined, and produces an element of $\T$.
	\item On the other hand, multiplying two elements of $\mathbb T$ does not make sense. To be convinced of it, we can remark that, for any non-zero torus element $x$, $0 \times x = 0$ while $1 \times x = x$. But since 0 and 1 are equivalent over the torus, these results should not be different. 
\end{itemize}



Recall the $\LWE$ assumption (Definition \ref{def:LWE}). If we rescale the elements of $\lweRing$ by dividing them by $q$, we get elements of the torus. We can then redefine seamlessly the $\LWE$ problem over the torus. Extensive details about this transformation can be found in \cite{these_chillotti}.


This brings two advantages:

\begin{itemize}
	\item $\LWE$ over the torus is \textit{scale-invariant}, which makes the analysis of the security and of the noise much simpler.
	\item The $\Z$-module structure propagate in the ring versions, as well in matrices spaces. Thus, it allows for very powerful generalizations of homomorphic schemes on a wide variety of spaces, like in \cite{chimera, chimera2}.
\end{itemize} 


When implementing the scheme in practice, torus elements are represented by integers in machine. The torus is thus seen as \textit{discretized}, which we denote by 

\[ \T_q = \left \{   \frac a q \;\middle|\; a \in \Z_q  \right \} \] 

with $q = 2^\Omega$ ($\Omega$ denotes the number of bits of precision of the concrete type, so often 32 or 64 bits in most implementations). The properties of the torus structure are preserved.


This thesis is mainly about practical instantiations of the scheme. So, for the sake of clarity we will adopt a notation closer to the reality of the objects manipulated in machine. So the torus elements will be seen as elements of $\lweRing$ (but keeping the algebraic rules imposed by the structure of $\T$), and the same will be applied for the ring extensions. 



\section{Encryption and Decryption in TFHE}


The plaintext space of TFHE is the \textit{discretized torus} $\plaintextTorus$. As explained in Section \ref{sec:torus_equivalence}, we trivially identify it to the ring $\plaintextRing$ with $p$ an integer. Let us consider a mapping $\rho: \plaintextRing \rightarrow \lweRing$ (in practice, $p \ll q$), defined as \[
\rho: m  \mapsto \rounding{\frac{m q} {p}}.
\]


The image of this mapping only reaches $p$ elements in $\lweRing$, forming the set $\left \{ \frac {k q}{p} \mid k \in \plaintextRing \right \}$. These elements are evenly distributed across $\lweRing$ and form what we refer to as \emph{sectors of $\lweRing$}, defined as: \[
\left \{ \left ( \frac{(2 k - 1)q}{2p}, \frac{(2k + 1)q}{2p} \right ) \mid k \in \plaintextRing \right \}.
\]

%\begin{figure}
%	\centering
%	\wrappedTorus{64}{5}{true}
%	\caption{}
%\end{figure}


\begin{figure}[htbp]
	\centering
	% First row: two figures side by side
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}
			\drawSingleRing{4}{4}{small}{true}{true}{true}
		\end{tikzpicture}
		\caption{Figure 1}
	\end{minipage}%
	\hspace{0.05\textwidth} % Space between the first and second figure
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}
			\drawSingleRing{64}{}{big}{true}{false}{false}
		\end{tikzpicture}
		\caption{Figure 2}
	\end{minipage}
	
	% Second row: one figure
	\vspace{0.5cm} % Space between rows
	\begin{minipage}{0.45\textwidth}
		\centering
		\wrappedTorus{64}{4}{true}
		\caption{Figure 3}
	\end{minipage}
	\caption{Truc}
\end{figure}


TFHE features two types of encryption that share similar structural patterns but operate within different mathematical spaces.


\paragraph{LWE Encryption.} Let $m \in \plaintextRing$ be a message and let $\lweSecretKey=(s_1, \dots, s_n)$ represent the secret key, sampled uniformly at random from $\B^n$. First, the message $m$ is encoded into the space $\lweRing$ by $\tilde m = \rho(m)$. A small random Gaussian noise $e \drawfrom \chi_{\lweSigma}$ is then added. Since $e$ is small, the noisy message $\tilde m + e$ remains within the same sector as $\tilde m$. Next, we construct the LWE ciphertext as a vector \[c = (a_0, \dots, a_{n-1}, b)\], where the $a_i$'s are sampled uniformly at random from $\lweRing$, and $b$ is defined by \[b=\sum_{i=0}^{n-1} a_i \cdot s_i + \tilde m + e.\]

Decryption is performed in two steps: first, we compute $\phi(c) = b - \sum_{i=0}^{n - 1} a_i \cdot s_i$, referred to as the \emph{phase} of the ciphertext. Then we round it to the nearest plaintext value: $\tilde m = \rounding{\frac p q \phi(c)}$. As long as $|e| < \frac{q}{2p}$, this rounding produces the right sector center, and thus we recover the correct plaintext value.

The security of this encryption relies on the hardness of the assumption $\LWE_{(q, n, \lweSigma)}$. 



\paragraph{GLWE Encryption.} This encryption mode mirrors the structure of $\LWE$ encryption but operates within polynomial rings. The secret key $\glweSecretKey$ is here represented as a vector $(S_0, \dots, S_{k-1})$, sampled uniformly at random from $\B_{N, q}[X]^k$. 
%
The message is encoded in a polynomial $\tilde M \in \glweRing$. The noise is also a polynomial from the same ring, whose coefficients are drawn from the distribution $\chi_{\glweSigma}$.
%
Similar to $\LWE$ encryption, the ciphertext takes the form \[C = (A_0, \dots, A_{k-1}, B)\] where the $A_i$'s are sampled uniformely at random in $\glweRing$ and $B$ is defined by: \[B = \sum_{i=0}^{k-1} A_i \cdot S_i + \tilde M + E.\]
%

Decryption follows the same steps as the $\LWE$ case: the phase is computed as $\phi(C) = \sum_{i=0}^{k-1} A_i \cdot S_i$ and rounded to the closest plaintext value.


The security of this encryption relies on the hardness of the assumption $\GLWE_{(q, k, N, \glweSigma)}$. Because the plaintext is a polynomial of degree $N$, it is possible to trivially batch up to $N$ plaintexts from $\plaintextRing$ by encoding them in the coefficients. With this method, they can be processed in parallel by the linear homomorphism presented below.


\TODO{Mentionner la version ``clé publique'' rapidement}



\section{Linear Homomorphisms}

On a torus, two operations are well-defined: the sum of two torus elements and the external product between a torus element and a \textit{scalar}.

It is not hard to see that both TFHE encryption modes are linearly homomorphic. We define the two operations \texttt{sumTFHE} and \texttt{clearMultTFHE}, that are well-defined for both encryption flavours:


\paragraph{$\sumTFHE{c}{c'}$:} Let $c = (a_0, \dots, a_{n-1}, b)$ and $c' = (a_0', \dots, a_{n-1}', b')$ be two $\LWE$ ciphertexts encrypting the messages $m$ and $m'$ from $\plaintextRing$, with respective noise variance $\sigma$ and $\sigma'$. Summing coefficient-wise both ciphertexts yields a new ciphertext $c'' = (a_0 + a_0', \dots, a_{n-1} + a'_{n-1}, b + b')$ encrypting $m + m'$ with a larger noise $e + e'$. The exact same algorithm works with polynomials for $\GLWE$ encryption. 


\paragraph{$\clearMultTFHE{c}{\lambda}$:} Let $c = (a_0, \dots, a_{n-1}, b)$ a $\LWE$ ciphertext encrypting a message $m \in \plaintextRing$ and $\lambda \in \plaintextRing$ a constant. Multypling each coefficient by the constant yields a new ciphertext $c' = (\lambda \cdot a_0, \dots, \lambda \cdot a_{n-1}, \lambda \cdot b)$ encrypting the message $\lambda \cdot m$ with a larger noise $\lambda \cdot e$.

The same algorithm works for polynomials. The constant can be either a scalar from $\plaintextRing$ or a polynomial itself.



%Actually, it may be useful to do it in Z_q blabla probl_me bruit blabla external product avec la décomposition

\TODO{Revérifier que je ne dis pas de conneries, et que faire de ce paragraphe ?}
We stress once again that the products between two elements of the torus is not well defined. Yet, it may be handy to be able to multiply two elements of $\plaintextRing$ regardless of the inherent torus structure of TFHE. To do so, it is necessary to \textit{lift} one of the terms to an external space (such as [...]) and run an external product. This requires to perform homomorphically the gadget decomposition introduced in Section \ref{external_products} which is not straightforward. This is called in the literature a \textit{circuit bootstrapping} (citer et faire le lien avec le packing ?)
\TODO{Vérifier dans la littérature si le terme \textit{Internal Product} est adapté, et pourquoi ce terme existe ?}



\section{A first advanced operation: the Key Switching (and a motivation for gadget decomposition)}



%Linear operations are nice and all but if we want to be able to do \textit{real} work, we need a multiplication operation. 
%
%The hard truth is: the multiplication between two torus elements is not defined. But will we let something as trivial as \textit{definitions} stop us ?
%
%Okay the ciphertext space has a torus structure, which is a module. Module means that one operation of external product exists: I can take a torus elements, multiply it by a scalar and it yields another torus element. So if we find a way to ``lift'' a torus element into the scalar space, we would have some sort of meaningful multiplication !
%
%In \cite{C:GenSahWat13}, the solution comes from a decomposition algorithm:
%
%...
%
%In TFHE, the authors realized that making this decomposition approximate allowed to gain an important performance factor, while not degrading the accuracy very much.


\paragraph{Some intuition on keyswitching}
Linear operations in TFHE are conceptually quite simple, but they are not enough to achieve fully homomorphic encryption.

Now, we introduce a more advanced operation: the \textit{keyswitching}. Let $c = \LWE_{\lweSecretKey}(m) = (a_0, \dots, a_{n-1}, b)$ be a $\LWE$ ciphertext encrypting a message $m$ under the secret key $s$. Keyswitching allows the server to homomorphically transform $c$ into a new ciphertext $c'$ encrypting this same message $m$ under another secret key $\lweSecretKey'$. To do so, it requires a \textit{keyswitching key} denoted by $\KSK$. Intuitively, $\KSK$ is simply an encryption of $\lweSecretKey$ under $\lweSecretKey'$. 

The rationale behind the keyswitching algorithm is to homomorphically evaluate the linear part of the decryption function (namely $b - \langle \vec a, \lweSecretKey \rangle$), encrypted under the key $s'$. As everything is linear, we can easily get a ciphertext $\LWE_{\lweSecretKey'}(b - \langle \vec a, \lweSecretKey \rangle) = \LWE_{\lweSecretKey'}(m + e)$. We start by explaining the $\LWE$-to-$\LWE$ version of keyswitching and then generalize to the ring case.

More formally, let $\KSK$ be the vector of encryption of every bit of the key $s$ under the key $s'$:

\[
	\KSK = \left \{ \LWE_{\lweSecretKey'}(s_i ) \right \}_{0 \le i < n}
\]

Notice how, if we treat the $a_i$'s of $c$ as scalar constants, we can homomorphically evaluate the product $- \langle \vec a ,\lweSecretKey \rangle$ with the basic linear operation of TFHE:


\begin{equation*}
	- \left\langle \vec a, \lweSecretKey \right\rangle \sim
	\sumTFHETernary{
		\clearMultTFHE{\LWE{\lweSecretKey'}(s_0)}{- a_0}
	}{
		\ldots
	}{
		\clearMultTFHE{\LWE{\lweSecretKey'}(s_{n-1})}{- a_{n-1}}
	}
\end{equation*}

Adding the constant $b$ is easy if we remark that the trivial ciphertext $(0, \dots, 0, b)$ is a valid instance of $\LWE_{\lweSecretKey'}(b)$. So we can write the full operation $b - \langle \vec a, \lweSecretKey \rangle$ as:

\begin{align*}
	\sumTFHEQuad{(0, \dots, 0, b)}{
		\clearMultTFHE{\LWE{\lweSecretKey'}(s_0)}{- a_0}
	}{
		\ldots
	}{
		\clearMultTFHE{\LWE{\lweSecretKey'}(s_{n-1})}{- a_{n-1}}
	}&\\
	 = \LWE{\lweSecretKey'}(b - \langle \vec a, \lweSecretKey \rangle) &\\
	 = \LWE{\lweSecretKey'}(m + e)
\end{align*}

and we effectively get a new encryption of $m$ under $\lweSecretKey'$.


However, there is a problem with this approach: recall that the $a_i$'s are uniformely distributed in the ring $\lweRing$. So they have in average a very large magnitude (about $\frac q 4$). Also recall that the scalar multiplication of TFHE increases the noise by the same factor as the multiplicative constant. So if one uses this first version of keyswitching, the noise would completely skyrocket and the result would be unusable.

Hopefully, there is a way to improve the noise growth in the scalar multiplication: it is called \textit{gadget decomposition}. We introduce it below:

\paragraph{Gadget Decomposition}

For the sake of clarity, we start by introducing an \textit{exact} version of the gadget decomposition. The variant used in TFHE is an \textit{approximate} one, which is conceptually only a small step more complex.


Recall that we want to compute the scalar product $a_i \cdot \LWE{\lweSecretKey}(m)$, with $a_i$ an arbitrary value in $\lweRing$, without noise explosion.

The core idea is to work with a \textit{decomposition} of the constant $a_i$ in some basis. Let $(\baseDecomp, \levelDecomp)$ be two integers such that $\baseDecomp^\levelDecomp = q$. We denote the decomposition of $a_i$ in this basis by:

\[
	a_i = \sum_{j=0}^{\levelDecomp-1} a_{ij} \cdot \baseDecomp^j
\]

In parallel, instead of working with a single ciphertext $\LWE{\lweSecretKey}(m)$, we use a collection of $\levelDecomp$ ciphertexts, each encrypting scaled version of $m$: 

\[
	\left \lbrace \LWE_{\lweSecretKey}(m \cdot \baseDecomp^j) \right \rbrace_{0 \le j < \levelDecomp}
\]

These ciphertexts are fresh encryption, so they all have the same fresh noise level $\lweSigma$.

Now, observe that instead of directly performing the product $a_i \cdot \LWE{\lweSecretKey}(m)$, we can instead performs the sum 

\[
	\sum_{j=0}^{\levelDecomp - 1} a_{ij} \cdot \LWE_{\lweSecretKey}(m \cdot \baseDecomp^j)
\]

which yields the correct result. The point of doing this is that the noise grows only by a factor $\baseDecomp \cdot \levelDecomp$ instead of $a_i$ (at the cost of storing $\levelDecomp$ ciphertexts instead of one).

\TODO{Vérifier l'argument avec une formule de bruit, et ajouter des références}
Note that we present here a very simple case. A rigorous formalism of gadget decomposition is developed in \cite{EC:GenMicPol19}, and some more analysis can be found in \cite{AC:Joye21}.


One of the innovations of TFHE is the realization that approximating the decomposition yields a significant performance improvement, at the cost of a slight degradation of the noise. So instead of taking exactly $\baseDecomp^\levelDecomp = q$, we pick smaller values in TFHE.


\paragraph{Back for a better keyswitching}

Coming back to the keyswitching algorithm, we pick decomposiion parameters $(\baseDecomp$, $\levelDecomp)$ and add a dimension to the keyswitching key to store each scaled version. So $\KSK$ becomes:

\[
	\KSK = \left \lbrace ( \LWE_{\lweSecretKey'} (s_i \cdot \baseDecomp^0, \dots  \LWE_{\lweSecretKey'} (s_i \cdot \baseDecomp^{j-1}) ) \right \rbrace_{0 \le i < n}
\]


and we replace the simple scalar multiplications in the keyswitching algorithm by scalar product between each decompositions. This gives:

\[
	(0, \dots, 0, b) - \sum_{i=0}^{n-1} \left \langle \decomp{\baseDecomp}{\levelDecomp}{a_i}, \KSK_i \right \rangle
\]




\paragraph{Generalization to $\GLWE$}


We introduced keyswitching in its $\LWE$-to-$\LWE$ form, but everything generalizes nicely to construct a $\LWE$-to-$\GLWE$ flavour. Here, $\KSK$ is a collection of GLWE ciphertexts, and the decomposition works coefficient-wise on the polynomials. The resulting $\GLWE$ ciphertext encrypts a polynomial whose degree-zero coefficient encodes the original message.

It is then possible to pack several $\LWE$ ciphertexts into a single $\GLWE$ one, by mutiplying the results by different monomials to move the encoded coefficient in a higher degree. They can then be summed. This is known in the literature as the \texttt{Packing Keyswitch}.

It is also possible (under several conditions) to evaluate functions while keyswitching by applying it on the decomposed scalars (making it a \textit{public} functional keyswitch) or on the encryption of the bits of the original secret key (making it a \textit{private} one). An in-depth tour of keyswitchs can be found in \cite{these_tap}.


\section{External Products}






Fin: this is easily explainable with the notion of Z-module

\TODO{Aorès ça, faire un lieb avec l'external product dans le cas général (et vec les Z-modules ?)}





\section{A look at Blind Rotation}

\TODO{Trouver le papier d'où ça vient, et l'expliquer aved des zolis dessins}




