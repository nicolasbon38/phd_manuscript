%!TEX root = ../thesis.tex

\chapter{Introduction to Fully Homomorphic Encryption}



\section{Why ?}





\section{Historical Background}



\TODO{Citer l'historique des schémas partiellements homomorphes, et des trucs "à niveaux" comme DHGV}


\section{The bootstrapping : breakthrough construction}
\label{sec:gentry_bootstrapping}


In 2009, Craig Gentry publishes the breakthrough paper \textit{Fully Homomorphic Encryption using Ideal Lattices} \cite{STOC:Gentry09}. In this work, he introduces the first ever fully homomorphic encryption scheme. Its main idea is the \textit{bootstrappability} of a scheme.

Bootstrappability is the ability of a scheme to evaluate homomorphically its own decryption circuit. Gentry shows that if a scheme achieves bootstrappability, then it achieves fully homomorphic encryption. Building on this theoretical result, he constructs a lattice-based bootstrappable scheme and demonstrates the first ever example of fully homomorphic scheme.

Since this foundational work, lattice-based constructions have remained the only serious candidate for fully homomorphic encryption. 

Such homomorphic schemes work by injecting some small random noise in the plaintext data before encryption. Its role is to ensure security, relying on computational hardness assumptions such as Learning With Errors (LWE) (we explain it further in Section \ref{sec:hardness_assumptions}). Because the noise is small, it can be easily removed during decryption by a simple rounding operation. 

Gentry's original scheme offered homomorphic additions and multiplications. However, because the plaintext messages are noisy, these operations increase the noise in the ciphertexts. So, if too much operations are performed, the noise gets so large that it becomes preponderant and blows the meaningful information contained in the ciphertexts.

This is where bootstrappability comes in. It gives access to an operation (the \textit{bootstrapping}) that decrypts homomorphically the noisy ciphertexts. But how can this help to achieve FHE ?

Imagine the server has a ciphertext $\vec c_1$ encrypting the (noisy) message $m +e_1$ under the secret key $\vec s_1$, where $m$ is the plain message and $e_1$ denotes the noise. Let us say that $\vec c_1$ is the result of a large number of homomorphic operations, so the noise $e_1$ is rather large. If we want to keep computing without losing information, we need to reduce the noise by a bootstrapping. 

To do so, the client needs to give to the server a \textit{bootstrapping key} $\BSK$. In order to create it, the client can treat the secret key $s_1$ as a message and encrypt it under another secret key $s_2$ to produce $\BSK = \texttt{Enc}_{s_2}(s_1)$. Now, if the server computes \textit{homomorphically} the decryption of $c_1$ using $\BSK$, it retrieves an encryption $c_2$ of the same message under the secret key $s_2$. But because, decryption removes noise, $e_1$ disappears and the ciphertext is fresh again !

Actually, \textit{all} the noise does not get removed (this would be a shame, because the security of the encryption relies on the presence of noise in the ciphertexts). As there is some noise in the encryption in $\BSK$, the result $c_2$ carries some noise $e_2$. But if things are well dimensioned, it is possible to get $e_2 \ll e_1$ and so gain some room for further computations.


Gentry's original scheme was merely theoretical, because the homomorphic operations and in particular the bootstrapping were extremely slow (and the size of the objects were extremely large). But since then, significant improvements have been achieved in FHE efficiency. Modern schemes are on the verge of being usable in practice for some use-cases. In the next section, we give a tour of the modern schemes and libraries that makes the FHE landcape as of today.


\TODO{Faire une figure}


\section{Current landscape of the FHE schemes and libraries}
\label{sec:landscape}

\TODO{Ecrire ça. Reprendre l'outline de la présentation de Gentry à FHE.org}


\section{Security Properties}


It is common in cryptography to modelize the security of a scheme by a \textit{security game}. In an idealized world, a challenger running the scheme is opposed to a polynomial-time attacker. This attacker has access to \textit{oracles} that they can query. For encryption scheme, one of these game is the \textit{indisguishability game}: the attacker pick two messages and send them to the challenger. The challenger flips a coin and encrypts one of the messages at random. They send this ciphertext (named the \textit{challenge ciphertext}) to the attacker, who have to guess which message has been encrypted. If the attacker can do better that random guessing (so guess right with probability larger than 0.5), we say that they have a \textit{non-negligible advantage}, indicating a vulnerability against the type of attack.

Usually, the ``graal'' for encryption schemes is \textsf{CCA2} security (or \textit{adaptative chosen-ciphertext security}). In the corresponding game, the attacker has access to an encryption and a decryption oracle, that they can query both before and after having received the challenge ciphertext, with the exception that they are forbid to query the decryption oracle directly on the challenge ciphertext.



By design, homomorphic schemes cannot achieve such security property because they are intrinsically \textit{malleable}. So a trivial attack would be to homomorphically add an encryption of zero to the challenge ciphertext and query the decryption oracle on the result. The oracle would accept the decryption and output the message, completely breaking the security of the scheme.

Actually, things are even worse: if the scheme is bootstrappable, then even \textsf{CCA1} security is unachievable. This corresponds to a \textit{non-adaptative chosen-ciphertext security}, the difference with \textsf{CCA2} being that the attacker is no longer allowed to query the decryption oracle after having seen the challenge ciphertext (so it modelizes a weaker security property). To understand the attack, recall that in Gentry's blueprint, the bootstrapping key is an encryption of the secret key. So, by querying the decryption oracle with the bootstrapping key, the attacker may recover the secret key and decrypt any ciphertext sent by the challenger. Some attacks are even possible with more constrained decryption oracles: for example \cite{SAC:LMSV11} demonstrates attacks with only an access to an oracle that tells if a ciphertext is valid or not, which seems a very practical concern.


Because these advanced security properties are so hard to achieve, the \textit{de facto} standard for FHE schemes has become \textsf{CPA} security (where the attacker has only access to an encryption oracle and no decryption oracle). This is the level of security targeted by most applied libraries. However, such security level is not sufficient in practice for most of the use-cases of FHE.


The problem has first been revealed in the work of \cite{EC:LiMic21} for approximate homomorphic schemes. In their work, they leverage the fact that the decryption function leaks the noise in ciphertexts to mount a secret-key recovery attack. They named this framework $\textsf{CPA}^\textsf{D}$ ($\cdot ^ \textsf{D}$ denoting the use of the output of the Decryption algorithm). To be protected against such attacks, users should be prohibited to disclose the results of decrypted messages. But in some use-cases (such as Multi-Party Computations), it is necessary to share the decrypted message. So the outputs of the decryption algorithm should be protected by injecting random noise to flood the leaked information \cite{EPRINT:CheHonKim20}. Actually, further works \cite{C:CSBB24, CCS:CCPSS24} have shown that non-approximate schemes are also vulnerable to $\textsf{CPA}^\textsf{D}$ attacks: instead of exploiting the noise leakage, the attacker can actively tamper with the noise in ciphertexts to trigger decryption errors and harvest information to mount a key-recovery attack.

Because of these security flaws, constructing practically secure FHE schemes for most of use-cases requires more work. It has already started in \cite{EC:ManNgu24, renard} where \textsf{CPA} secure FHE schemes are augmented with some machinery to prove the well-formedness of ciphertexts. They develop the notion of \textsf{vCCA} (for \textit{verified chosen ciphertext security}) and implement it in practice with SNARKS \cite{SNARKS} (succing non-interactive argument of knowledge). 


